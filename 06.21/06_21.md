# 22.06.21 Java 수업 내용


## 재귀함수

자신을 정의할 때 자신을 리턴하는 함수
다시(재) 귀환(귀) 하는 함수



## stack overflow

나중에 들어간게 먼저 나온다
제일 최근에 호출된 함수의 리턴 값이 먼저 계산되어야 한다
하나가 끝나기 전에 새로운 하나가 호출되고 그것을 처리하기 전에 또 새로운 것이 호출되고
이게 끝없이 진행되어서 스택 오버 플로우가 발생한다



## 컬렉션(Collection)

[자료](https://st-lab.tistory.com/240)

자바에서 1.2에서 정의됨.
자바에서 미리 만들어놓은 데이터를 수집하고 관리(추가,생성,삭제,초기화,크기,리스트)해주는 목적의 클래스와 인터페이스

- 왜사용하는가? 
  - 일관된 API(Application Programming Interface)
  - 프로그래밍의 노력 감소 // 바퀴를 또 발명하지 말라(이미 구현 된 것을 또 개발할 필요 없음)
  - 프로그램 속도 및 품질 향상

- 선언법
(**중요**)   컬렉션종류<데이터타입> 이름 = new 컬렉션종류<데이터타입>();
예) HashSet<String> set = new HashSet<String>();

- 객체 리스트
  - ##### Set
    구현클래스 : HashSet, TreeSet, LinkedHashSet
    중학교때 배웠던 "집합". 순서가 없다.  데이터의 중복을 허용하지 않는다.
    Hash : 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환(매핑)하는 것
     해쉬는 유니크함을 보장하기 때문에 순회할 필요가 없다. -> 검색을 매우 빠르게 할 수 있다.
     동일한 입력값에 대해서는 동일한 결과값(다이제스트)를 갖는다.
     이 다이제스트의 값을 index로 활용한다.
    함수 : equals() : 들어있는 요소가 같은지 검사, hashCode(), removeAll(), contains(값), remove(값)   add(), size()
    정의예 : HashSet<String> alphabetSet = new HashSet<>();
            for(String spell: alphabet){
                alphabetSet.add(spell);
            }
    
  - ##### List
    구현클래스 :  ArrayList, LinkedList, Vector
    배열의 최대 단점인 초기화 했을 때의 크기로 고정되는 것을 해결한 자료구조
    순서가 있는 데이터의 집합으로 데이터의 중복을 허용
    함수 : add(값),  addAll(리스트),   remove(인덱스),   clear(),   size()
          get(인덱스),   indexOf(값),   lastIndexOf(값)
    반복문과 결합 :   향상된for문  for(자료형 이름 : 리스트)
                     while(iterator.hasNext())
    예제 : 
    ``` java
        // ArrayList 선언
        ArrayList<Integer> al = new ArrayList<Integer>();
  
        // ArrayList에 데이터 입력
        for (int i = 1; i <= 5; i++)
            al.add(i);
  
        // 결과 출력
        System.out.println(al);   //[1, 2, 3, 4, 5]
  
        // 3번 데이터 제거
        al.remove(3);
  
        // 결과 출력
        System.out.println(al); //[1, 2, 3, 5]
  
        // 하나씩 가져와서 결과 출력
        for (int i = 0; i < al.size(); i++)
            System.out.print(al.get(i) + " ");  //1 2 3 5
    ```

  - ##### Queue
    구현클래스 :  LinkedList, PriorityQueue

  - ##### Map
    구현클래스 : Hashtable, HashMap, TreeMap
    키(Key), 값(Value)의 쌍으로 이루어진 데이터의 집합
- 함수 리스트
add(), remove(), clear(), size()

// 직접 위의 함수들 구현해보는것 좋은 공부다.  private int[] nums,    private int current;



## String 문자열 클래스

이제야 눈에 보이는 스트링. 원시타입아니다.
자바에서 컬렉션으로 만들어 놓은 자료구조다.
charAt(), compareTo(), concat(), indexOf(), trim(), toLowerCase(), toUpperCase(), substring, length(), isEmpty(), contains() 문자의위치반환 없으면-1, matches(정규식) 등의 함수가 있다.
스트링은 값이 달라질때 새로운 객체를 만들어서 할당받는다.

//자바에서 문자열1에서 문자열2를 포함한 갯수 찾기
```java
	  public int getCountInclude(String str1, String str2){
	      boolean include = true;
	      int count = 0;
	      include = str1.contains(str2);	//포함되었는지 참거짓 판단
	      while(include) {	//포함되었다면
	         count++;
	         int where = str1.indexOf(str2);	//시작하는 위치 파악
	         str1 = str1.substring(where+str2.length());
	         System.out.println("str1 : "+str1);
	         //방금찾은거를 빼고 남은 문자열을 부모로 업데이트
	         //substring 함수는 인자가 하나면 해당위치부터 이후로 끝까지 자르는 함수
	         include = str1.contains(str2);
	      }
	      return count;
	   }

```



## 제네릭(Generic)

- 뜻 :  포괄적인, 일반적인
Object 를 만들면 사용(저장, 로드)하기전에 형변환 작업을 해줘야하는 불편함이 존재한다.
범용 컬렉션의 장점과 특화된 클래스의 장점을 모두 겸비한 템플릿.
- Java5에서 추가
- 컬렉션, 람다식, 스트림, NIO(New IO)등에서 널리 사용되므로 제네릭을 이해하지 못하면 API 문서를 정확히 이해할 수 없다.

- 목적
자료형을 일반화. 정의시가 아니라 인스턴스 생성시 자료형을 결정하도록 한다.
우리가 어떤 자료구조를 만들어서 배포하려고 할때 '여러 데이터타입을 지원하고 싶다.'  그러면 String에 대한 클래스, Integer에 대한 클래스 등등을 하나하나 타입별로 만들어줘야하나? 너무 비효율적이다.
제네릭은 이런 문제를 해결해준다.
그렇게 강조했던 메소드의 정의와 호출 다시한번 보자. 어떤 이름으로 넘어오든지 정의한 영역내에서는 이 이름으로 쓰겠다였지?
마찬가지로 제너릭이라는것은 어떤 데이터타입으로 넘어오든지 이 정의한 영역내에는 넘어온 그 데이터타입으로 쓰겠다 라고 하는것이다.
즉 데이터형을 정의시 명시하지 않고 호출할때 정할 수 있도록 일반화 한것이다.
클래스내부에서 지정하지 않고 외부에서 지정도록 한 것이다.
엄밀히 말하자면 컴파일때 해당 타입으로 캐스팅 하는 것이다.

```java
//일반
List list = new ArrayList();
list.add("hello");
String str = (String) list.get(0);

//제네릭
List<String> list = new ArrayList<String>();
list.add("hello");
String str = list.get(0); // 타입 변환을 하지 않습니다.
```


- 특징
보편적(암묵적)으로 매개변수의 타입으로는 아래의 이름을 쓴다.
    <E> : Element
    <K> : Key
    <N> : Number
    <T> : Type
    <V> : Value
특정범위내로 좁혀서 제한하고 싶다면 extends, super, ? 를 활용한다.
예를들어 <K super T>   이면 T타입의 조상만 가능하고 K로 쓰겠다는 말이다.

- 문법
  - 정의 : 클래스 또는 인터페이스 이름뒤에 <타입파라미터>
     - 생략하면 컴파일러가 제네릭 관련 문장에서 자료형의 이름을 추론한다. 이걸 다이아몬드 표시라고 한다.
     - 타입 파라미터로 명시할수 있는것은 참조타입만 가능하다.
     - 여러개의 타입변수는 쉼표로 구분하여 명시한다.
  - 사용 : 본문에서 그 이름을 데이터타입처럼 사용하면된다.


- 예
```java
public class Box<T>{
    // 클래스 뒤에 <T> 타입 파라미터를 명시했기 때문에 변수의 타입으로 사용 가능합니다.
    private T t;
    public T get() { return t; }
    public void set(T t){ this.t = t; }
}
```

- 장점
1. 런타임에 잘못된 타입이 들어올 수 있는것을 컴파일 단계에서 방지한다.
2. 반환값에 대한 타입 변환(캐스팅) 및 타입검사에 들어가는 노력 줄어듬
3. 코드의 재사용성이 높아진다.



## 중요한 것

데이터타입(원시형, 참조형)
객체, 클래스, 인스턴스
생성자
추상클래스, 인터페이스
오버라이드, 오버로드
배열, 리스트



## 람다식(Lamda Expression)

> 자바8에 함수적 프로그래밍 기법으로 도입됨. 람다가 포함되면서 자바가 완전해졌다고 말하는 이가 있을정도.
> 익명함수를 생성하기 위한 식
> y = f(x) 형태   를 (타입 매개변수) -> { 실행문 }   으로 정의
좋든 싫든 자바의 람다식은 선택이 아닌 필수가 되었다.
장점 : 1. 코드가 매우 간결해진다.
        2. 인스턴스 생성안하고 기능하나만 필요할때
        3. 함수 이름을 생각하지 않아도 됨
        4. 컬렉션요소를 매핑해서 쉽게 집계할 수 있다.
단점 : 가독성이 안좋아진다.
    함수이름이 없기 때문에 stacktrace보고 디버깅하기 어렵다.
    이 함수가 있음을 인식하기가 어렵다.
결론 : 저런 단점들때문에 고급개발자는 람다식 쓰지말라고도 하는사람 많다.
    본문이 3줄안에 끝나고 단 한번만 쓰임을 보장할 수 있고 행동이 명확할 때만 제한적으로 사용.
문법 : 인풋데이터 -> 함수본문
예  :1. 줄임이 없는 예
  (String s) -> { System.out.println(s); }

  2. 매개변수가 하나일때 괄호생략. 본문이 하나일때 중괄호와 세미콜론 생략
   s -> System.out.println(s)
   (a,b) -> a+b

  3. 제네릭으로 사용한 예
  Calculate<Integer> ci = (a,b) -> a+b;
  System.out.println(ci.cal(4,3));



## ERD

Entity Realationship Diagram
개체 관계도(그림)



## 툴

- erwin : 유료 (실무. 월 천만원)
- erdcloud.com : (오른쪽에 광고가 있지만 무료로 사용할 수 있음)
  노란색은 pk추가, 파란색은 기본컬럼 추가
  상단아이콘은 테이블복사, 테이블색, 테이블정보, 삭제
  자동으로 쿼리를 만들어주는데 부모가 없는데 자식을 먼저 생성하는 등 순서가 안맞는 경우, 해당 RDBMS에서 지원하지 않는 함수를 쓰거나 등의 문제가 있어서 한방에 정상 실행안되므로 조금 수정해줘야한다.
  fk가 있는놈들을 나의 pk지정할때 하나씩 분리되어있는데, 로 이어줘야한다.
  1064 SYNTAX ERROR 뜨는데 만들어진 쿼리에 첫번째 CREATE 문에 이상한 스페이스가 숨어있다.

```
    <details>
    <summary>여러개 테이블에서 foreign키 설정하는법</summary>
    <div markdown="1">
    ALTER TABLE `brand_coffee`
    ADD CONSTRAINT `FK_brand_TO_brand_coffee_1`
    FOREIGN KEY (
       `brand_id`
    )
    REFERENCES `brand` (
       `brand_id`
    )
    ,
    ADD CONSTRAINT `FK_brand_TO_brand_coffee_2`
    FOREIGN KEY (
       `class_id`
    )
    REFERENCES `coffee` (
       `class_id`
    );


    insert into brand
    (brand_id, brand_name, brand_content, brand_logo)
    values
    ("starbucks", "스타벅스", "세계최대의 커피브랜드", "스타벅스 로고");

    insert into coffee
    ( class_id, class_name, class_content, class_img)
    values
    ("americano", "아메리카노", "커피의 기본", "아메리카노");


    insert into brand_coffee
    (brand_id, class_id)
    values
    ("starbucks", "americano");
    </div>
    </details>
```
- draw.io
- Exerd



## 좋은 사이트

- https://helloblog.net/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B6%8C%ED%95%9C-db-%EB%AA%A8%EB%8D%B8%EB%A7%81/
- [엔코아 이화식](https://www.youtube.com/playlist?list=PL9gStYgm-otNZQpj2lQsOSRuiwwtEftiE)
- [생활코딩 관계형데이터베이스](https://www.youtube.com/playlist?list=PLuHgQVnccGMDF6rHsY9qMuJMd295Yk4sa)
- [OKKY ERD](https://www.erdcloud.com/d/PK2Ae7d4asTRqHpHx)



## 좋은설계

- 높은 응집도(cohesion). 낮은 결합도(coupling) => 업무의 변화에 최대한 영향을 적게받는 유연한 시스템
  좋은 설계 : 변경사항이 들어오면 변경사항만 바꾸면 되는 시스템.
          키보드만 고장나면 키보드만 갈아끼우면 되는시스템
          스페이스바만 고장나면 스페이스바만 갈아끼우면 되는 키보드.
          스페이스바가 고장나면 스페이스바만 갈아끼울수있는 키보드
  안좋은 설계 : 변경사항을 처리하기위해 기존의 잘되던것들도 뜯어 고쳐야 하는 시스템.
          키보드만 고장나면 컴퓨터를 교체해야되는 되는시스템
          스페이바가 고장나면 키보드 전체를 갈아야되는 키보드



## 모델링

- 정의
  복잡한 현실에서 우리가 관리할 정보를 정확히 규명하여 단순명료하게 핵심만 뽑아서 만들어내는 것.
모델링이 아무리 복잡해도 현실이 훨씬 복잡하다.
일반인이 아파트 설계도를 보면 복잡하다고 하지만 아파트 공사짓는 사람이 설계도를 보면 빠진게 많다고 불평할거다. 엔드유저는 매우 간단한 도면을 받는다.
프로그래머는 아파트를 사는 사람이 아니라 짓는사람이다.
초갓집을 지을때는 간단한 평면도 또는 설계도가 없이도 집을 지을수 있다.
그러나 대형빌딩을 지을때 설계도는 없어서는 안되고 웬만한 설계도로는 집을 지을수 없다.
창문이 어디에 있다 정도가 아니고 mm단위로 너비, 높이, 두께, 재질, 설치위치 등이 다 명시되어 있어야한다.
- '어떤 모델을 만들어야겠다' 라고 미리 생각하지 않는다. 모델링은 결과의 툴이 아니라 과정의 툴이다.
유능한 수사관은 범인이 누구인지 알고 잡지 않는다. 현장에서 하나씩 알아가면서 완성해나가는것이지 알고나서 그리는것이 아니다. 즉, 업무를 몰라도 할 수 있다는 말이다. 어느누구도 그 회사의 업무를 다 알수없다.
백지상태로 가서 해당업무를 아는 담당자에게 묻고 확인해가며 이끌어내는것이다.
- 객관화 되어야 한다. 누구도 꼼짝 못할 논리가 있어야 한다.
- 판단력이 있어야한다. 맞고 틀리는게 아니다. 최선의 답을 찾아나가는 과정이다.
  모델링적으로는 90점짜린데 개발까지 감안하면 10점짜리일수 있다.
  데이터베이스를 모르면 그 판단을 못한다.
- 방법을 안다고 해서 실제로 모델링을 할 수 있게 되는것이 아니다. 그래서 어렵다.
- 스포츠 선수는 선수로서의 기간은 짧고 이후에 코치나 감독이 된다. 모델러는 프로그래머의 노후에 가기 좋은 길이다.
모델러는 오케스트라의 지휘자다. 아무소리도 안내지만 모든 소리를 조율한다.

- 데이터가 더러우면 프로그래머가 고생한다. 그걸 다 프로그램단에서 제어해줘야 되기 때문에. 데이터가 단순하고 깨끗하면 초급도 일할수 있고 일을 시키기도 쉬워진다.
- RDB가 생기기전에는 어떤 설계를 하더라도 속도가 비슷비슷했다. 그러나 RDB는 설계에따라서 속도가 100배넘게도 차이난다. 3일 걸리던게 3초만에 끝날 수 있다.
- 현재만 봐서는 안된다. 요구는 계속 바뀌거나 생겨날것이고 직원과 회사는 변화고 사회적인 상황도 변한다. 그것들을 생각해서 설계해야한다.
- 정보는 연결되어있어야 한다. 어디에도 연결되지 않고 뚝 떨어진 정보는 없어야 한다.
- 데이터는 기업의 자산이다. 그런데 이력관리가 안되게 설계해놓은곳이 너무 많다.
예를들어 부서를 옮겼으면 현재부서만 저장되는것이 아니라 이대까지 언제 어디로 옮겼는지 내역이 저장되어 있어야한다.


- ### 목적
  - 업무내용의 정확한 분석
  - 실제 데이터베이스를 생성하는 기초

- ### 방법
  1. 기능모델링 먼저
  가장 일반적인 방법
  기능에 따른 데이터의 흐름인 DFD(Data Flow Diagram)를 보고 데이터모델설계.
  DFD는 추상적, 흐름적, 계층적이다.
  이 방법의 문제는 기능에 따라 데이터가 종속된다는 점이다.
  기능이 바뀌면 모델이 바뀌게 된다.
  급여와 사원의 데이터 구조는 유지한채로 주는 방법이 바뀌어야 되는데 주는 방법이 바뀌게 되면 데이터 구조가 바뀌게 된다.

  1. 병렬로 동시 진행
  주로 대형프로젝트에서 사용
  반드시 다수의 전문가가 있을때 사용해야 한다.
  전문가는 자기일만 잘하는것이 아니라 자기일에 영향을 미칠 요소들을 다 관리한다.
  그래서 각 분야의 전문가들이 긴밀하게 연결되어 타분야의 이상요소를 빨리 감지하여야 한다.

  1. 데이터모델링 먼저
  객관적, 구체적, 흐름없음
  업무를 잘 모르는 시점에 할 수 있어야 하기 때문에 전문적인 모델러가 필요하다.
  가장 이상적인 방법이다.



### 중요한 사항들

- **데이터 모델에는 시간개념이 없다.** 프로세스가 아니다. 흐름이 있는게 아니다.
- 어떤 사원이 월급을 받았든 안받았든 상관이 없다. 사원과 월급과의 관계만 정해주는거다.
- 예외에 계속 집중하지 마라. 언젠가는 그얘기를 할때가 온다. 그때해야한다.
- 모델링은 무조건 **1촌관계만 그려준다.** 삼촌사촌 등은 명시하지 않아도 관계에 의해서 저절로 정해진다.
- 풍경을 2시간동안 열심히 머릿속에 저장하고 집에와서 그리면 그게 풍경화인가?
아무리 업무 설명을 잘듣고 정리하고 와도 집에와서 그걸 그리면 그게 뭔가
현장에서 실제 업무속에 들어가서 실시간 피드백을 들으면서 모델링을 해야한다.
- 주관이 들어가지 않고 있는 그대로를 찍는 사진이 있고, 주관적인 느낌을 담아 작품을 만드는 사진이 있다.
**모델러는 작가다. 모델은 작품이다.** 지금의 상황 그대로를 그려내는일을 하는것이 아니다.
- 업무가 내 한계를 벗어난다면 한층을 한번에 못올라가서 계단을 놓듯이, 내가 감당할수있는 단위로 잘게잘게 쪼개서 단위별로 완성하고 합치면 된다. 그러면 아무리 높은곳이라도 올라갈 수 있다.



## 팁
- 4개컬럼은 거의 모든 테이블에 들어간다.
(생성일, 생성자, 수정일, 수정자)
- 계산으로 가져올수있는 테이블은 컬럼으로 만들지 않는다.
- 날짜 이런식으로 말고 무슨날짜인지 명확하게 인지되도록.



## 무결성 제약조건 5가지

컬럼에 제약조건을 5가지 종류로 걸 수 있다.
- NOT Null   = 빈값이 들어가선 안된다.
- unique    = 해당테이블에서 유일하게 존재해야함. 단, NULL은 여러개 있을수있음
- PRIMARY Key(기본키)  = unique && not null. 한행을 식별하기위한 기준
    - PK는 유니크와 낫널이다. (O)    유니크와 낫널이면 PK다.(X)
- FOREIGN Key(외래키)  = 참조하는 테이블(부모)에 존재하는 값들만 사용해야 함
    - 반드시 존재하는 값은 PK이기 때문에 다른 PK를 받아온다고 생각하면 된다.
- CHECK   = 조건에 부합하는 데이터만 입력 가능



## Entity (엔티티)

- 엔티티는 **집합**이다. 나중에 테이블로 변경된다.
  (중요)메인엔티티는 **개체**든 **행위**든 하나의 순수한 집합이여야 한다.
  집합은 정의 가능한 사물 또는 개념을 의미한다. 그러나 집합이라고 다 엔티티는 아니다.
  예를 들어 '납입자'는   납입이라는 엔티티와 사람이라는 엔티티가 연결된 관계다.  '청구서' 이런거 마찬가지겠지.
- 엔티티가 잘 못뽑는다면 정의가 잘 안됐기 때문에 그런것이다.
- 엔티티 이름 짓기 매우 중요하다. 누가보더라도 어떤 집합인지 명확하게 느껴지도록.
- ### 순서
  **후보 엔티티** 뽑기 -> **키 엔티티**(부모가 없이 자기 스스로 탄생가능) -> **메인엔티티**(업무의 중심) -> **자손엔티티**
- 프로그램과 화면에서 가장 많이 다루게될것은 자손엔티티가 될것이다. 근간이 되는 데이터는 잘 변하지 않는다.
- 디비설계는 이 모델링을 가지고 데이터베이스의 테이블 형태로 변환하는 비교적 기계적인 일이다.

- ### 엔티티인지 검증(판별 규칙)
1. 동질성을 가진 집합인지(정의한 집합 테두리에 포함되는지)
1. 독립성을 가진 집합인지(부분집합이 아니여야하고 교집합이 없어야 한다.)  엔티티끼리 교집합이 생긴다면 문제가 생긴거다. 예) 가입자, 납입자
1. 가로*세로로 면적이 되어야한다.
가로(속성)가 2개이상이고, 세로(데이터)가 2개 이상이어야 한다.
1. 행위엔티티와 개체 엔티티를 합친 엔티티는 분리해야된다.
1. 최소한 하나이상의 다른 엔티티와의 관계를 가지는지
1. 식별자가 있어야한다.



## 기본키

- **한 테이블의 유일함을 결정짓는 속성**
- 한테이블의 기본키는 하나의 컬럼에만 지정할수있다? 맞을까? 틀릴까?
- "테이블은 오직 하나의 기본키를 가질 수 있다." 이건 정확한 정의다.
그런데 그 말을 "테이블의 PK는 오직 하나의 컬럼으로만 설정할수있다" 라고 잘못이해하는 경우가 대부분이다.
기본키는 여러개의 컬럼의 복합키로 구성될수 있다.
```
예를들어 '판매실적'을 저장하는 테이블이 있다.
어떤 판매실적을 하나의 행으로 다룰건지 그 목적에 따라 기본키가 달라지진다.
총 컬럼은 날짜, 영업사원(판매자), 판매제품, 판매처, 판매처직원, 판매제품의하나당가격, 판매제품의 수량  이 있을때
우리는 누가, 언제, 어디에, 어떤 제품을 팔았는지에 대한 판매실적을 담고 싶다고 하자.

2021-08-18-14시, 배성원, 리모콘, 흥국생명, 홍길동, 50만원, 100개
PK는 뭘로 지정해야할까?
여기서 PK가 하나가 된다면 어떻게 될까? 예를들어 영업사원이 PK이면? 판매사원별로 판매실적을 저장하는 테이블이 되는것이다.
한사람이 한날짜에 한번씩만 기록되도록 날짜와 사원번호를 넣으면? 그 사원은 판매실적을 한날짜에 한번밖에 저장 못하게 된다.
마찬가지 원리로
  같은날짜에 한사람이 하나밖에 등록하지 못하면 안되니까 판매처 추가
  같은날짜에 한사람이 한판매처에 한번밖에 등록하지 못하면 안되니까 제품 추가.
결국 날짜, 사원번호, 판매처, 제품명 4개의 조합이 복합키가 되어야 한다.
```
후보키는 유일성과 최소성을 만족시켜야함



## 인조키

마땅한 자연키가 없거나 복합키가 너무 많을때 편의를 위해 자연적이지 않고 인공적으로 부여한 키를 말한다.
PK가 너무많은 컬럼으로 구성되면 조인할때 너무 불편하다.
(조인할때는 유일한 식별을 위해 식별되는 모든컬럼을 WHERE조건에 걸어줘야 되기 때문에.)

예) 글번호, 주민등록번호
- ※주민등록번호를 회원테이블의 pk로 잡으면 생기는 문제
갑자기 주민등록번호를 보안정책에 의해 별도로 암호화해서 보관해야합니다? 하면 피똥쌈.
여기저기서 유저 참조할때 FK로 사용했다? 프로그램 전체를 다 갈아엎어야됨.



## 참조키

	- FK가 정의된 테이블이 자식 테이블이다.
	- 참조되는 테이블은 부모 테이블이다.
	- 부모테이블은 미리 생성되어 있어야 한다.
	- 부모테이블에 존재하는 값만 입력가능하도록 하는 제약조건이다.
	- 부모테이블을 참조하는 자식데이터가 있으면 부모 데이터를 지울수 없다.
		- ON DELETE CASCADE : 부모의 행이 지워지면 자식의 행도 같이 지워진다.
		- ON DELETE SET NULL : 부모의 행이 지워지면 자식의 행은 NULL이 된다.
  - 데이터타입이 반드시 일치해야한다.
  - 참조되는 컬럼은 PK 또는 UNIQUE여야 한다.
  - 비식별관계로 FK가 걸리면 ERD상에는 보이지만 실제 제약조건으로는 안걸린다.



## 모델링의 순서

- 요구사항 분석 -> 개념적 모델링(주제별 핵심엔티티, 관계) -> 논리적 모델링(정규화. 모델링의 핵심) -> 물리적 모델(실제컬럼명, 데이터타입, 길이, 실제저장공간, 분산, 인덱스 설계, 성능최적화) -> DB스키마 구현후 스크립트 파일로 보관 -> 테스트데이터 입력
- 논리적 모델링까지는 어떤 데이터베이스를 쓸건지는 전혀 생각하지 않는다.
[좋은예제](https://rutgo-letsgo.tistory.com/138)

- 실무에서 가장 요긴하게 사용될 논리모델과 주제영역은 완전하게 연결되는것이 이상적.
- 주제영역이란 기업이 사용하는 데이터의 최상위 집합. 예를들어 인사, 자재, 판매, 재무 등
- 논리적 모델링이 전체 모델링 과정중 가장 오랜시간이 소요된다.
- 논리모델링에서는 속성명을 한글로 표현한다.

 - 논리 모델링에서 물리 모델링으로 넘어오면서 고려하는 작업
   -Super/Sub 관계의 엔티티를 몇 개의 테이블로 만들 것인가
   -배타적(Arc) 관계 엔티티의 외부키(Foreign Key)를 몇 개로 할 것인가
   -성능 향상을 위해 테이블을 추가해야 할 것인가 혹은 통합해야 할 것인가
   -통계 작업을 위해 합계(Summary) 테이블 같은 임시성 테이블을 몇 개로 할 것이며, 유일키를 무 엇으로 할 것인가
   -테이블의 칼럼을 다른 테이블에 중복할 것인가, 중복한다면 어떤 애플리케이션이 관련되어 있는 가, 인덱스의 설정, 스냅샷(Snapshot) 또는 뷰(View) 등의 객체가 필요한가
   -분산 환경에서 테이블을 중복할 것인가, 중앙에 필요한 테이블을 따로 가져갈 것인가
   -데이터가 분산 환경에서 이동 시 문제를 어떻게 해결할 것인가



 - 속성의 추가 VS 엔티티의 추가
   우리가 했던거 기능5를 넘어서는 기능이 추가되면 계속 컬럼을 추가하는 작업을 해줘야했잖아. (배경을 모른다면 색깔로 생각하자.)
   이것을 모델1이라고 하자.
   그래서 기능테이블을 따로 뺐는데 이걸 모델2라고 하자.
   모델1에서 모델2로 진화한것이 아니다. 어느모델이 더 좋고 나쁜것이 아니라 우리 상황에 더 적합한것이 좋은거다.
   모델1은 직관적이다.
   모델2는 추상화되었다. 확장이 쉽다.



## 데이터 설계

데이터 모델을 그릴때는 '행위(동사)', '대상(목적어)', '주체(주어)'를 구분하라.
예) 행위에 의한 관계 : 강사, 강의한다, 수강생.
예) 존재에 의한 관계 : 사원, 소속된다, 부서
DB모델링이라는것은 데이터의 관계를 눈으로 볼수있도록 모델링하는것.



## ER모델

  Entity Relationship Model.    ERD의 D는 Diagram
  요구사항으로부터 얻어낸 정보들을 개체, 애트리뷰트, 관계성으로 기술하는 개념적 데이터 모델.

  학생 한명은 개체(Entity),  네모(□)로 표현. 후에 테이블이 된다.
  개체가 갖는 속성(Attribute)는 원(○)으로 표현. 후에 컬럼이 된다.
  개체간의 관계(Relation)는 마름모(◇)로 표현. 후에 pk와 fk가 된다.


  바커표기법가 IE표기법이있다. 김이사님이 쓰는건 IE표기법.
  바커표기법은 한쪽에서 나가고, 다른쪽에서 나간걸 합친것.



## [관계](http://wiki.gurubee.net/pages/viewpage.action?pageId=26743462)

  IE표기법을 기준으로 설명.
  관계는 무조건 그 행을 유니크하게 구분할 수 있어야 하기 때문에 조인할때 한쪽의 테이블 기본키에 해당하는 컬럼을 모두 가져와야 한다.
  관계는 존재에 의한것인가 행위에 의한것인가 2가지로 구분된다.
  관계명(Membership), 관계차수(Cardinality), 관계선택사양(Optionality) 3개를 표기해줘야한다.
  애매한 동사를 피하고 현재형으로 표현한다.
 


## Cardinality(카디널리티). 관계차수. Degree

- 테이블이 몇대 몇으로 연결되어 있느냐 따지는 것
- 목적어 쪽에 부호가 붙는다
- 3가지 1:M,   M:M,   1:1
- 1은 세로선, N은 까치발로 표현
- 예) 1:1 담임, 교실,    1:N 글-댓글,  부서-사원    N:M 주문, 제품
- 1:M관계가 90%. 수평관계보다 수직관계가 많다.
  1:N 관계는 자식테이블에 FK로 집어넣어 관계를 표현한다.
- M:M관계는 모델링이 진행되는 과정의 덜풀린것이다. M:M은 최종물리모델에서는 구현될 수 없기 때문에 모델링이 끝나면 M:M관계 없어야한다. 다대다 관계를 실제로 구현하기 위해선 각 테이블의 PK를 FK로 참조하고 있는 **연결테이블**(**관계테이블**, **관계해소테이블**)을 사용해야 한다.
        M:M관계에는 업무가 녹아있는 거다. 업무의 깊이가 깊으면 M:M을 풀면 계속해서 M:M이 나온다.
        M:M을 관계에서 관계엔티티로 언제 풀거냐 하는걸 잘 결정해야한다.
    )



## Optionality

연관되는 엔티티의 값이 반드시 존재해야하는지(Mandatory), 존재하지 않아도 되는지(Optional)를 의미
없어도되면 Optional의 동그라미로 표현

아래그램과 같이 양쪽이 선택이면 의무적인 관계가 없는것과 마찬가지이지만 연관관계는 존재하므로 관계선을 삭제하는것은 바람직하지 않다.
상위엔티티쪽의 옵셔널리티가 필수가 되는것이 좋다.

대부분의 경우 1:n관계에서 n쪽에는 optional이 붙게 된다.이는 물리적 구현이 어려워서이기도 한다.

관계는 Cardinality, Selectivity, 방향 이 세 가지 요소로 구성된다. 기호가 어디에 붙냐가 정말정말 헷갈리는데 **목적어 방향**에 붙는다고 생각하자.

주어쪽은 하나(One) 또는 각(Each)로 읽는다.
목적어쪽은 아래와같다.
( 목적어쪽에 선 하나 : 하나의 A는 하나의 B로 구성되어있다,
  목적어쪽에 삼발이 : 하나의 A는 N개의 B로 구성되어있다.
  목적어 쪽에 허수아비 : 하나의 A는 0개 또는 1개의 B로 구성되어있다,
  목적어쪽에 O에삼발이 : 하나의 A는 0개 또는 N개의 B로 구성되어있다.
또 쉽게 알아낸것은 수많은 자식들이 당신만 바라보고있어요. n:1관계. 1쪽이 부모. 많은놈이 1쪽을 참조한다.)

    예) 부서는 사원을 여러명 가진다. 사원쪽에 까치발.
       사원은 하나의 부서에만 소속될수있으면 부서쪽에 한발.
       사원이 여러 부서에 소속될수 있으면 부서쪽에 까치발.
       사원은 한개의 부서에 반드시 소속되어야 하면 선하나.



## 실제 구현

관계는 PK와 FK로 구현된다.
1:N은 볼것도없이 1쪽의 PK를 N쪽이 FK로 가져가면 된다.
1:1은 누구에게 FK를 줄지 애매하다. 의미를 뜯어봐야한다. (회원, 휴면회원 테이블)
N:M은 어디에 PK, FK를 주더라도 모순이 생기기 때문에 즉, 실제로 불가능하기 때문에 중재자가 필요하다.



### 설계의 정합성은 형식으로 판단한다.

내용(데이터)는 이해를 돕기위한 참조일뿐.
그래서 설계를 잘하려면 업무를 몰라야 한다라는 말이 있다. 추상화된 형식으로 확장성 높도록.
더이상 추가할게 없는것이 아니라 더이상 제거할것이 없을때 설계가 완성된다.



### 설계는 제약의 표현이다.
제약하지 않은건 다 가능하다고 봐야한다. 고객이 거기에 0 안들어와요, null 안들어와요. 이런거 믿지말고 시스템적으로 제약을 해야한다. 반드시. 안그럼 뒤통수 세게 맞는다.



## 식별관계와 비식별관계(실선과 점선)

- ### 식별관계 = ### 실선
  Identifying Relationship. 부모가 없으면 존재할수 없는 관계.
  데이터의 정합성(자식테이블에 데이터가 있으면 부모에 반드시 있음을 보장)
  키상속. 부모의 pk가 자식의 pk로 들어오는 경우.양쪽의 키가 모두 기본키일때.
         반드시 부모엔터티가 있어야 자기자신의 엔터티가 생긴다.
         키를 상속했다는 말은 너의 모든 데이터를 내가 빠짐없이 사용하겠다는 말.
	부모데이터가 자식어딘가에서 참조되고 있다면 못지운다.
	자식데이터는 지울수있다.
  요구사항이 변경되었을경우 구조변경이 어렵다.
  1:m관계가 계속 식별로 연결된다면 자식으로 갈수록 pk의 갯수가 계속 늘어나는 문제가 있다.

- ### 비식별관계 = ### 점선
  참조하되 기본키가 아닌 일반키로 참조.
  변경되는 요구사항을 유동적으로 수용할 수 있다.
  부모데이터와 독립적인 자식 데이터를 생성할 수 있다.
  데이터 정합성을 지키기위해 별도의 비지니스 로직이 필요하다.
    (부모의 pk만 가져오는것이지, 부모의 일반컬럼들을 자식엔터티로 내려받는다는 보증이 안되었기 때문에 정확한 정보를 위해서는 안해도되는 조인을 해야된다.)
  키상속 아님.부모의 pk가 자식의 일반속성이 되는 경우. 한쪽만 기본키일대.
         부모가 없어도 자식이 생길수있다. 자식은 남기고 부모가 먼저 소멸될 수 있다.
	부모데이터, 자식데이터 제각각 지울수있다.
  (즉, 데이터 무결성을 보장하지 않으며 자식데이터가 존재해도 부모데이터가 없을수있다는 말)

- 식별관계와 비식별관계중 무엇을 선택해서 연결하는지는 높은 내공을 요구한다.
기본적으로는 다음조건에 해당할 경우 비식별자관계로 만들면된다.
약한관계, 자식테이블의 독립적pk가 필요, sql이 너무복잡하게 만들어져서 개발생산성이 저하됨.
ERD클라우드에서 비식별관계는 실제 물리적으로는 구현되지 않는다. 설계를 보고 화면에서 콤보박스를 만들든가 하는식으로 해결. 반드시 정합성을 유지해야하는 경우만 식별관계를 쓰고 웬만하면 비식별로 설계하는 것을 권장.


- 선택적 비식별관계와 필수적 비식별관계
  NULL이면 선택적 비식별관계
  NOTNULL이면 필수적 비식별관계
  선택적 비식별관계는 NULL을 허용하므로 조인할때 외부조인을 사용해야 한다.
  필수적 비식별관계는 NOT NULL로 항상 관계가 있음을 보장하기 때문에 내부조인만 사용해도된다.

  => 필수적 비식별관계를 하느냐 식별관계를 하느냐의 판단 기준
  1. 식별관계로 묶다보면 자식테이블의 기본키 컬럼이 점점 늘어난다.
  결국 조인할때 SQL이 복잡해지고 기본키 인덱스가 불필요하게 커질수 있다.
  자연키컬럼의 조합일경우 식별관계가 좋고
  인조키(대리키)일경우 필수적 비식별관계가 좋다. 비지니스 요구사항은 시간이 지남에 따라 변하기 때문.
  2. 데이터의 정합성이 중요할경우 식별관계
  예) 수강내역은 학생이 없다면 존재의 의미가 없다. 그리고 하나의 학생은 여러 수강내역을 가질수있다.



## ERD표기법

- Baker표기법(DA#)
  DA표기법은 영국 컨설팅회사 CACI에 의해 처음 개발되었고 리차드 바커에 의햇 지속적으로 업그레이드 되었다. 오라클에서 Case Method로 채택하여 사용.
  Mandatory 반드시 저장해야될 속성에는 *로 표시, 일반적인 Optional속성에는 o로 표시.
  관계는 실선을 잘라서 반반씩 표현한다.
- IE Notation표기법(ERWin)
  IE표기법은 Information Engineering Notation은 1981년 발표되었고 80년대 중반 James Martin에 의해 체계가 정리되어 본격적으로 활용되었다. 까마귀발 모델(Crow's Foot Model)이라고도 한다.
  식별자는 식별선 위에 따로 표기한다.