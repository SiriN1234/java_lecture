## 예외처리
- 에러(Error) : 개발자가 처리할 수 없는 심각한 영역의 문제. 반드시 프로그램이 종료되는 문제.
    - 예) 메모리 부족,
    - 문법에러 : 컴파일 전에 걸러지는 에러
        
- 예외(Exception) : 개발자가 프로그램을 죽이지 않고 대처할 수 있는 문제.
    - 런타임 중 발생. 컴파일은 통과 됐는데 막상 실행하니까 발생함
    - 모든 예외는 자바의 Exception이라는 클래스를 상속 받는다.
    - 예) Nullpointer, OutOfIndex, Arithmetic, ClassNotFound
    
- 예외처리 하는 법 : try, catch, finally 문법 사용



## static

전역화 = 정의된 지역에 상관없이 프로그램이 실행되어 종료될 때 까지 유지
인스턴스화 할 때가 아니라 클래스를 컴파일 할 때 메모리에 올라간다.
그 때 올라가서 프로그램이 종료될 때까지 유지되니까 '공유'되는 성질을 갖게 된다.



## 부동소수점

사람은 10진법을 쓰지만 컴퓨터는 2진법을 씀
(2진법)0010 -> 2의3승 * 0 + 2의2승 * 0 + 2의1승 * 1 + 2의0승 * 0 = 2

- 고정소수점 : 부호비트, 정수부, 소수부로 구성
    - 표현할 때 32bit(4bite)를 사용 함
    - 맨 앞 1bit는 부호비트
    - 그 뒤 15bit는 정수부
    - 나머지 뒷부분 16bit는 소수부

- 부동소수점 : 부호비트, 지수부, 가수부로 구성
    - 맨 앞 1bit는 부호비트
    - 지수부 8bit
    - 가수부 23bit

```
double total = 0.0;
		for(int i = 0; i < 100; i++) {
			total += 0.1;
		}
		
		System.out.println(total);
```
결과값 : 9.99999999999998
		
0.1을 100번 더하기 한 누적값 -> 10
컴퓨터는 십진수 0.1이라는 값을 '정확하게' 저장할 수 없는 구조다.
왜냐하면 부동소수점을 썼기 때문에
그러면 부동소수점을 쓰는 이유?
정확도를 아주 조금 잃은 대신에 훨씬 넓은 범위의 값을 표현할 수 있음

그렇다면 부동소수점의 연산 오차를 어떻게 해결할 수 있을까?
자바의 부동소수점 데이터타입을 쓰지 않고 BigDecimal을 사용

```
BigDecimal total2 = new BigDecimal(0.0);
		
		for(int i = 0; i < 100; i++) {
			total2 = total2.add(new BigDecimal(0.1));
		}
		
		System.out.println(total2);
		// add, substract, multiply, divide, remainder, compareTo, max, min 등이 있음
```



## cmd에서 자바 실행

1. 프로젝트 우클릭 - export - runnable jar
2. 해당 경로로 가서 쉬프트 우클릭 - 현재위치에서 powershell 열기
3. ls명령어로 파일이 있나 확인
4. java -jar 파일명 실행

- 한글이 깨진다면?
$profile을 입력해서 해당 위치에 있는 psl파일(Microsoft.PowerShell_profile.psl)
//C:\Users\human\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1에 $env:LC_ALL = 'C.UTF-' 넣어서 한글 안 깨지게 하기

- 환경 변수 설정
    - 변수이름 : CLASSPATH
    - 값 : %JAVA_HOME%\lib

- PATH에 클래스패스 등록
    - %CLASSPATH% 추가

IDE에서 한다면 위의 과정은 필요가 없다.
IDE가 알아서 잡아주거나, 못 잡으면 IDE 안에서 세팅하면 된다.
하지만, 언제나 IDE에서 개발할 수 있다는 보장이 없다. (예를들어 리눅스 환경)
그런 상황에서 위를 실행하면 된다.

실무에서는 리눅스 기반의 서버에서 스케쥴러로 여러가지 프로젝트들을 관리한다.
ex) 매일 새벽 2시에 어떤 db의 데이터를 어떤 db로 옮기는 작업



## 인터페이스

#### 박철수 implements 의사

철수는 의사의 역할을 해야되기 때문에 의사면 반드시 구현해야 될 행동들을 의무적으로 구현하는 용도


#### interface 의사

- 수술하다
- 진료하다
- 처방하다


#### 박철수 extends 사람

철수가 가지고 있는 속성과 행동의 대부분이 사람에 이미 구현되어 있기 때문에 상속 받는 용도

- 추상 클래스는 '존재'의 개념이으로 상위 개념을 뽑는 개념
- 인터페이스는 '기능'의 강제화의 개념
    - 반드시 이 이름으로, 이 파라미터로, 이 리턴타입으로 함수를 재정의 해야한다는 약속

- 회원 클래스
- 의사 클래스
    - 내과의사, 소아과의사, 안과의사, 치과의사
- 홍길동 implements 안과의사



## 패키지

패키지는 논리적 주소,
폴더는 물리적 주소
실제로 서로 다른 폴더에 있더라도 패키지가 같으면 프로그램은 같은곳에 있다고 인식한다.
물리적 폴더가 없더라도 논리적으로 같은곳에 있다고 인식한다.
목적 : 같은 이름의 변수를 쓸 수 있게 하기 위해서.
  같은 이름의 변수를 서로 다른 클래스에서 쓸 수 있듯이
  같은 이름의 클래스를 서로 다른 패키지에서 쓸 수 있다.
// 프로그램이 커지게 되면 같은 이름의 클래스가 생겨날 가능성이 높다.
예) a폴더 밑의 b폴더 밑의 c폴더에서 import kr.co.human.클래스1
    x폴더 밑의 y폴더 밑의 z폴더에서 import kr.co.human.클래스1
    같은 위치의 클래스를 가져올 수 있다.

예2) import kr.co.human.클래스2
     import com.google.클래스2
     클래스 이름이 같지만 오류 없이 둘 다 구분해서 가지고온다.



## 다형성

- 관련개념 : 상속, 오버라이딩, 형변환
- 하나의 코드가 여러 자료형으로 구현되어 다른 실행결과를 실행되게끔 하는 기술
- 하나의 객체가 여러 가지 타입을 가질 수 있는 것
- 조상클래스 타입의 참조변수로   자손클래스의 인스턴스를 참조할 수 있다.
- 부모는 자식을 담을 수 있지만, 자식은 부모를 담을 수 없다.
  - 남자는 사람이다. 여자는 사람이다.   는 맞는 말이지만  사람은 여자이다. 는 틀린말
  - 도형 도형1 = new 원();    도형 도형2 = new 사각형();
  - 자식에만 있는 멤버나 메서드는 버려진다.
  - 함수(몬스터)  함수(플레이어)  함수(골렘)
    오버로드가 작동되면서 같은 함수지만 다르게 작동.
    함수(캐릭터) -> 하나의 함수로 몬스터, 플레이어, 골렘을 받을 수 있게 됨.
- 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나
- 다형성을 잘 활용하면 유연하고, 확장성있고 유지보수가 편리한 프로그램을 만들수 있다.
- 실제 인스턴스 타입을 확인하려면 instanceof연산자

예)
```java
Animal 독수리 = new 독수리(); //이름이 같아도 서로 다른 놈으로 인식됨
Animal 호랑이 = new 호랑이();
Animal 코끼리 = new 코끼리();

public void moveAnimal(Animal animal){
  animal.move();
}
가 있을때 아래와 같이 호출하면
test.moveAnimal(독수리)
test.moveAnimal(호랑이)
test.moveAnimal(코끼리)
다 제각각의 오버라이드된 move가 호출된다.
```

예2)
```java
고객 customerT = new GoldCustomer(10030, "Edward");
고객 CustomerP = new VIPCustomer(10050, "Kim")
```



## Object클래스

어떤 자료형이든 상관없이 다 관리할 수 있는 자료형식.
모든 클래스의 최종 부모는 Object다. 그러므로 모든 클래스는 Object다.
객체라면 기본적으로 가지고 있어야 할 속성과 행동을 정의하고 있다.
(모든 객체가 공통적으로 가지고 있어야 할 속성과 행동이 정의되어 있다. 사실 Object클래스에는 필드가 ㅇ벗고, 11개의 메소드만 있다.)
- toString() // 16진수로 된 인스턴스의 주소를 출력
- equals() // 참조 변수가 가르키는 값을 비교하기 때문에 주소 비교. 같은 인스턴스인가 물어봄.
  - String에서만 오버라이딩해서 같은 값인지 비교
- clone()
- getClass() // 해당 객체의 클래스 타입을 반환