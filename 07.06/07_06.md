# 22.07.06 Spring 수업 내용


1. 클라이언트가 서버에게 어떤 정보를 달라고 요청
   GET = URL에 쿼리스트링으로 정보가 전달(보통 화면 전환용)
   POST = URL에 노출 안되고 숨겨서 전달(보통 데이터 처리용)
2. 컨트롤러에서 요청 받기
   @GETMAPPING, @POSTMAPPING으로 해당 요청을 리스닝 하고 있다가 요청이 들어오면 처리할 함수를 정의, 실행.
   화면에서 넘어온 데이터는 name의 이름으로 넘어온다.
   파라미터에 직접적인 이름을 안쓰고 객체로 넘겼다면, 카멜케이스 명명규칙에 따라서 자동으로 getter 함수를 실행해서 가져온다.
3. 해당 요청을 처리할 서비스 호출
   서비스 인터페이스, 인터페이스의 구현체 ServiceImpl
   서비스를 @Autowired해서 주입받아 사용.
   스프링이 알아서 해당 데이터 타입을 자동으로 검색해서 가장 적절한 것을 매핑시켜 준다.
   ex) BoardService를 implements한 서비스 임플이 2개라면??
       dup 에러가 쓴다. 무엇을 가져가야 할지 스스로 판단하지 못하기 때문에
4. ServiceImpl실행
   현재는 return mapper.getPage(bno); 식으로 매퍼를 호출하는 것이 서비스의 본문의 다인데,
   mapper의 역할은 쿼리를 실행하는 것이기 때문에 쿼리를 실행하기 전에 처리해야 할 일이 있으면 여기에 넣어주면 된다.
   쿼리를 실행 후에 처리해야 할 일이 있으면 마찬가지로 여기에.
5. Mapper 인터페이스가 실행
6. 쿼리 실행
   Mybatis의 namespace에 의해서 인터페이스와 xml(쿼리)이 매핑되어 있음
   인터페이스의 함수명과 쿼리id가 매핑된다.
7. 반환결과를 ServiceImpl이 받음
8. ServiceImpl의 리턴 값을 컨트롤러가 받음
9. 컨트롤러에서는 Model 객체에 데이터 주입
10. 데이터를 화면에서 출력
    Model에 addAttribute의 첫 번째 파라미터로 전달한 이름을 el 표기법으로 출력 ${이름}

MVC(Model, View, Controller)
Model : 로직
View : 화면
Controller : 요청에 따라 로직과 화면을 컨트롤

VO(View Object), DTO(Data Transfer Objecct)는 위의 MVC의 계층(layer)간 데이터를 전달할 때 쓰이는 객체
예) 유저의 이름, 성별, 나이, 포인트, 레벨을 화면에서 컨트롤러로 전달해야 한다면?
    각각 전달하면 코드가 길어지고, 변수 관리도 어려워지니까 객체에 묶어서 하나만 전달하면 되기 때문에
    여러 개의 변수를 쓰기 보다는 하나의 객체를 쓴다.
    높은 응집도를 만든 것. 관심사가 같은 것끼리 묶은 것.

CRUD(Create, Read, Update, Delete) : 읽기, 쓰기, 수정, 삭제

스프링 환경세팅, 게시판 CRUD 이렇게 오늘까지 한 것이 스프링의 기본

INDEX = 색인
p.60000 책을 볼 때 특정 주제에 빨리 찾고 싶으면 뒤에 있는 색인에서 찾아서 해당 페이지로 바로 갈 수 있음. 색인이 5페이지.
"원시형 데이터타입" -> p.2100
"참조형 데이터타입" p.3200
"객체" p.4000

참조형 데이터타입이 800페이지만큼의 분량이었는데 추가된 컨텐츠 때문에 802 페이지가 됐다고 치자.
참조형 데이터타입 이후의 인덱스들을 모두 2페이지만큼 증가시켜줘야 색인의 역할을 이행할 수 있게 된다.
색인을 쓰게되면 '원래' 데이터를 변경할 때 '색인'데이터 CRUD를 해줘야된다. 즉, 2번의 CRUD 작업이 일어나게 된다.
색인을 잘못쓰게 되면 이 단점 때문에 오히려 데이터 접근 속도가 더 느려진다.
색인을 쓰는 이유는 저 2번의 CRUD 작업보다 색인을 통해서 접근하는 것이 매우 빠르기 때문.

p.6 근데 색인이 2페이지(우리의 현 상황) 색인을 만들고 관리하는 것에 본래 데이터에 비해서 큰 에너지를 쓰고있는 것
"원시형 데이터타입" p.2
"참조형 데이터타입" p.2
"객체" p.2

인덱스를 써야하나요? 인덱스가 있으면 없는 것보다 좋나요?
=> 인덱스를 쓰면 인덱스 만큼의 디스크 공간이 더 필요하고, CRUD가 2번 일어나고, 인덱스를 정렬하는데 시간이 
   추가로 더 든다.
   그러니까 수정, 삭제가 잘 일어나지 않고 조회 위주의 많은 데이터가 있는 테이블이라면 쓰는게 좋고 아니면 안 쓰는게 좋음.
   잘못쓰게 되면 배보다 배꼽이 더 큰 꼴이 된다.

스프링을 써야하나요? 스프링을 배우면 좋은건가요?
=> 목적이 뭔지에 따라 다르다.
   여러명의 개발자들이 엔터프라이즈 앱을 자바로 개발해야된다면 배워야 하지만,
   개인이 간단한 프로젝트를 만들려고 하면 오히려 안 좋을 수 있다.

내가 스트레스를 받으면서 공부해야하나요?
=> 내가 취업하고자 하는 것이 그 정도의 능력을 필요하지 않으면 스트레스 받지 않고 편안하게 살면되고
   내가 취업하고자 하는 곳에 그 정도의 능력을 필요로 한다면 스트레스 받더라도 공부.

이거를 배우는데 드는 노력과, 스트레스와 에너지를 들이고나서 얻는 효과가 더 이득인가, 손해인가.

WHY가 아직 잘 안세워졌으면 배워야 함.
WHY가 확실하면 내 길이 아닌 것은 버리고 선택과 집중을 해서 내가 가야 될 길에 더 많은 노력.

< 크다라고 인식 할 수도 있고, 태그의 시작으로 인식 할 수도 있다.
이것을 '크다'라고 인식하기 위해 cdata 사용

리스트 -> 상세로 갈 때는 정상
list.jsp(글 목록)에서 moveForm 안에 hidden으로 pageNum과 amount가 있다.
글 번호를 클릭하면 그 moveForm에 hidden으로 bno를 추가해서 /board/get 요청을 하고있다.
그래서 리스트에서 디테일 조회는 잘 되고있다.

상세 -> 리스트로 갈 때는 비정상
get.jsp에서 list_btn을 클릭하면 infoForm의 #bno를 지우고, /board/list 요청을 하고있다.
그래서 /board/list를 [GET]으로 받는 컨트롤러에서는 '어떤' 리스트를 보일지에 대한 정보가 없다.
그래서 기본 1과, 10으로 세팅된 리스트를 보여주고 있다.

해결 프로세스 1. 상세조회 화면을 띄울 때 Model에 페이지 정보(Criteria)를 같이 전달한다.
             -> 글 번호만 전달하던 컨트롤러를 페이지 정보도 같이 전달하도록 수정해준다.
해결 프로세스 2. 상세조회 화면에서 리스트 화면을 전환하는 get 요청을 보낼 때 전달받은 페이지 정보를 같이 전달한다.