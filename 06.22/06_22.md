# 22.06.21 Java 수업 내용

## Collection Framework

자바에서 미리 만들어 놓은 자료구조
직접 만드는 것보다 일관성 있고, 빠르고, 안정적이고 품질이 높다.

- 만드는 법 : 객체 만드는 법과 비슷한데 제네릭이 들어감.
    - 객체 만드는 법 : 객체타입 이름 = new 객체타입(파라미터);
    - 컬렉션타입<데이터타입> 이름 = new 컬렉션타입<데이터타입>(파라미터);
  
데이터타입은 원시형 데이터타입이 들어갈 수 없다. 참조형 데이터타입만 들어갈 수 있다.

1. Set : 집합
2. List : 크기와 고정되지 않은 배열
3. Queue : 선입선출
4. Map : 키와 벨류의 쌍

각각의 자료구조에 미리 만들어져있는 함수를 활용해서 CRUD를 한다.
CRUD = Create, Read, Update, Delete 만들고 읽고 수정하고 지우고
함수에는 get, add, remove, size, indexOf 이런 것들이 있다.


## Iterator

반복자. 향상된 for문에서 뒤에 들어갈 수 있는 데이터타입이 이터레이터였다.

```
for(자료형 이름 : 이터레이터) {
    모든 원소에 대해 실행할 본문
}

while(iterator.hasNext()) {
    이터레이터명.next(); // 다음 원소 읽어오기
}
```



## Generic

함수 정의시 파라미터의 이름이 무엇으로 넘어오든 상관없이 정의할 때 정한 이름으로 쓰듯이 데이터타입을 정의시에는 대명사처럼 받고, 인스턴스 생성시 결정되도록 하는 문법
즉, 어떤 데이터타입으로 넘어오든지 그 넘어온 데이터타입으로 쓰겠다는 것
데이터타입이 다를 때마다 오버로딩 해줘야되는 작업을 없애준다.

예)
```
List<String> list = new ArrayList<String>();
```

List를 만든 사람은 List를 정의할 때 제네릭을 사용했다.
그래서 List의 인스턴스를 만드는 사람은 ```<String>```을 사용하면 String 형태의 리스트가 만들어지고, ```<Integer>```를 사용하면 Integer 형태의 리스트가 만들어지고, ```<Double>```을 사용하면 Double 형태의 리스트가 만들어진다.
하지만 List 정의시의 코드는 하나다. 하나가 저것들을 다 처리할 수 있다. 제네릭을 썼기 때문



## ERD

- Entity Relationship Diagram. 객체관계도
  - RDB(관계형 데이터 베이스) 오라클, mysql은 설계에 따라서 성능차이가 엄청남

- PK : primary Key. 기본키.
  - 한 테이블에서 유일한 행을 결정짓도록 하는 컬럼들의 조합
  - 한 테이블에 pk는 무조건 하나만 있어야한다.  0개, n개는 안된다.
  - 그 말이 한 테이블에 pk는 하나의 컬럼으로만 구성되어야 한다는 말이 아닌데 그렇게 이해하기 쉬우니 유의해야 한다.
- NN : Not Null. 빈 값이 있으면 안된다.
- Unique : 이미 테이블에 기존 값이 있으면 중복되어서 들어갈 수 없다. 유일해야한다.
- FK : Foreign Key. 외래키
  - 다른 테이블의 데이터를 참조해서 사용할 때 다른 테이블의 하나의 행을 유일하게 식별해서 가져와야한다.
  - 다른 테이블의 PK를 참조하게 되는데 그것이 내 테이블에서는 FK라고 불린다
- CHECK : 조건에 부합하는 데이터만 들어올 수 있다.

FK를 가지고 올 때 2가지 타입이 있다. 식별관계와 비식별관계

#### 식별관계

참조테이블의 PK가 내 테이블의 PK로 들어오는 경우
ERD에서 실선으로 표현
내 테이블에 데이터가 있을 때 부모 테이블에 그 데이터가 있음을 보장한다.
부모 테이블에서 다른 테이블에서 참조되고 있는 데이터를 지우려고 하면 못 지우거나, 참조 데이터까지 지워야되기 때문

#### 비식별관계

참조 테이블의 PK가 내 테이블의 일반컬럼으로 들어오는 경우
ERD에서 점선으로 표현
다른 테이블에서 참조하고 있더라도 부모테이블에서 참조되고 있는 데이터를 지울 수 있다.

#### Cardinality(관계 차수)

Optional : 있을수도 있고 없을수도 있다
1 : 0, 1, n 관계를 '목적어'쪽에 표현해준다.



## 람다식(Lamda Expression) / 람다함수

> 자바8에 도입된 함수적 프로그래밍 기법이다. 람다가 포함되면서 자바가 완전해졌다고 말하는 이가 있을정도다.
> 익명함수를 람다함수라고 한다.  익명함수는 반환타입과 이름이 없다.
> 함수형프로그래밍이 무엇인지 먼저 알아야 한다. 쉽게 말하자면 최대한 많은 함수를 순수함수로 만들어 유지보수하기 쉽도록 만드는 패러다임이며 디테일하게 말하자면 아래와 같다.
순수함수 : side effect(부작용 : 부수효과)가 없는 함수
  부수효과는 인풋과 아웃풋이라는 함수 본질이 아니라 반환값 이외에는 함수밖에서 관찰할수 있는 상태변화가 발생하는 모든것을 말한다.
  사이드이펙트를 가진 함수가 많아지면 디버깅하기가 매우 어려워지게 된다. 각 함수 내부를 뒤져서 이게 어디에 영향을 주는지 파악해야한다.
  인풋이 같으면 언제나 같은 아웃풋이 나와야 한다.

  예를들어서 현재시간을 함수내부에서 사용한다면 인풋이 같을때 아웃풋이 달라질 수 있기때문에 순수함수가 아니다.
  순수함수가 될려면 외부에서 시간을 주입받아야 한다.
  그러다보니 동시에 여러함수들이 호출돼도 문제가 없다. 병렬처리가 가능하다.
  그리고 함수형 프로그래밍에서는 모든것을 객체로 취급한다. 함수는 일급객체로 취급한다.
**그래서 사실 람다식은 익명함수가 아니라 익명객체다.**
자바스크립트나 파이썬같은곳에서는 함수가 일급객체라 람다식 사용이 쉬운데
자바는 객체지향프로그래밍 문법이라 함수는 함수고 객체는 객체라 문법적으로 이상해진다.
여기서 어려움이 발생한다. 자바스크립트의 화살표함수로 (a,b) -> a>b? a:b 짜면 매우 간단한다.
let max = (a,b) -> a>b? a:b;
max(5,7);
그런데 자바에서는 아래와 같이 클래스에 종속적이게 만들어야한다.
new Object(){
  int max(int a, int b){
    return a>b? a:b;
  }
}
// 클래스명 인스턴스명 = new 클래스명();
앞에 대입받는 인스턴스가 없기 때문에 이름이 없는 익명 객체다.
객체의 선언과 생성을 동시에 하고있다.

- 자바의 모든 메소드는 클래스 안에만 위치할수있다. 
  즉, 자바에서는 메소드만 따로 전달할 수 있는 방법이 없다.
  그래서 자바에서는 메서드만 전달할 수 있는 방법이 없다. 
  그래서 **매번 인스턴스를 만들어서 전달**해줘야 하고 매우 불편했다. 그것을 해결하기 위해 도입한것이 람다식이며 
  함수형언어에서 함수는 일급객체이기 때문에 클래스에 독립적이다는 개념을 이용한 것이다.
> (**중요**)익명함수를 생성하는 식으로 보이지만 런타임시에 익명 구현 객체를 생성한다.
> 정의문법 :  (데이터타입 매개변수) -> { 실행문; }
              반환타입과 메서드명을 지우고 {} 앞에 ->를 넣으면 된다.
              매개변수가 하나일때 괄호생략가능. 단, 타입을 명시적으로 줬다면 생략불가.
                예 (x) -> { return x * x * x;}; x -> { return x * x * x;};
              본문이 한줄일때 중괄호생략가능. 세미콜론 생략해야됨. 
              그런데 그하나의 문장이 return문이면 {} 생략불가
              그런데 아예 return 키워드를 빼면 또 {} 생략가능
                x -> x * x * x;
              매개변수의 타입이 추론가능하면 생략가능(대부분 생략가능)
              그래서 (int x, int y) -> {return x+y};
                     (x, y) -> {return x+y};
                     (x, y) -> x+y;
- 예시로 연습
```java
  int max(int a, int b){
      return a>b? a: b;
  }
  변환 : (a,b) -> a>b? a: b

  int printVar(String name, int i){
    System.out.println(name +"="+i);
  }
  변환 : (name, i) -> System.out.println(name +"="+i)

  int square(int x){
    return x*x;
  }
  변환 : x -> x*x

  int roll(){
    return (int)(Math.random()*6);
  }
  변환 : ()->(int)(Math.random()*6)


  for(int i=0; i<10; i++){
    System.out.prinln(i);
  }
  변환 : IntStream.range(0, 10).forEach(콜백함수);
        // 그런데 자바에서는 함수만 함수의 파라미터로 전달해줄 수가 없다. 그래서 아래와 같이 쓴다.
        IntStream.range(0, 10).forEach((int value) -> System.out.println(value));
```
- (**실제구현**)
  자바에서는 문법상 메소드만 만들 순 없잖아. 클래스안에 있어야하지.
  그런데 우리가 만들려고하는건 함수 하나다. 그래서 람다식용으로 함수하나만 포함하고있는 인터페이스를 만들거다.
  함수가 단 하나만 있는 인터페이스를 **함수형 인터페이스** 라고 한다. 우리가 쓰레드할때 썼던 Runnable 인터페이스도 run함수 하나뿐인 함수형 인터페이스다.
  함수가 하나밖에 없기 때문에 JVM이 자동으로 무조건 그놈으로 매핑을 해 줄 수 있다.
  그래서 인터페이스 명 = () -> {본문}  을 하면 해당 인터페이스의 익명 구현 객체로 생성된다. 그놈을 인스턴스에 넣어서 쓸거다.
  코드를 예로 한번 보면 훨씬 이해가 쉽다.
  1. 함수형 인터페이스(어떤 함수 하나에 대한 약속) 만들기
  public interface Add{
    public int add(int x, int y);
  }
  2. 쓸 클래스의 함수안 람다식 구현하기
  Add 아무이름 = (x,y) -> {return x+y;};   // 우변{return x+y;}은 람다식만 쓴거
                                          // 이부분이 위에서 말한 자동매핑 부분이다.
  3. 호출하기
  System.out.println(아무이름.add(2,3));
- 매개변수타입은 런타임시 대입되는 값에 따라 자동으로 인식될수 있기 때문에 일반적으로 언급하지 않는다.
- 장점(익명함수(람다식)의 장점이지 자바에서는 이 장점들이 상쇄된다)
  1. 코드가 매우 간결해진다.
  2. 인스턴스 생성 안하고 기능실행 // 클래스의 인스턴스를 생성하지 않는거지 자바 문법상 인스턴스는 있을 수 밖에 없다
  3. 함수이름 생각 할 필요없음
  4. 컬렉션요소를 매핑해서 쉽게 집계할 수 있다.
- 단점
  1. 가독성이 안좋아진다.
  2. 함수이름이 없기 때문에 stacktrace보고 디버깅하기 어렵다.
  3. 이 함수가 있음을 인식하기가 어렵다.
- 결론
  위의 단점들때문에 람다식 쓰지말라고도 하는개발자들도 많다.
  본문이 3줄안에 끝나고 단 한번만 쓰임을 보장할수있고 행동이 명확할때만 제한적으로 사용.

- @FunctionalInterface
Functional Interface라는것을 알려준다. '구현해야 할 추상 메소드가 하나만 정의된 인터페이스'를 가리킨다.
그래서 함수가 2개이상있으면 에러를 발생시킨다.